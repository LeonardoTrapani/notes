#class/index

## Fundamental Concepts

### Problem Definition
- [[Sorting Problem Definition]] - Formal definition of the sorting computational problem

### Analysis Framework  
- [[Running Time Analysis Principles]] - Fundamental principles for analyzing algorithm performance
- [[Types of Algorithm Analysis]] - Worst-case, average-case, and best-case analysis methods
- [[Asymptotic Notation]] - Mathematical framework for comparing algorithm efficiency

## Sorting Algorithms

### Basic Algorithms
- [[Insertion Sort Algorithm]] - Simple quadratic-time sorting algorithm
- [[Insertion Sort Complexity Analysis]] - Detailed complexity analysis of insertion sort

### Advanced Algorithms  
- [[Merge Sort Algorithm]] - Divide-and-conquer sorting with optimal complexity
- [[Merge Sort Complexity Analysis]] - Recurrence relation analysis showing $\Theta(n \lg n)$ complexity

## Algorithmic Paradigms

### Design Strategies
- [[Divide and Conquer Algorithms]] - Fundamental paradigm for efficient algorithm design
- [[Recurrence Relations]] - Mathematical analysis of recursive algorithms

## Comparative Analysis

### Algorithm Comparison
- [[Sorting Algorithms Comparison]] - Performance comparison and selection guidelines

## Key Results

1. **Insertion Sort:** $\Theta(n^2)$ worst and average case, suitable for small inputs
2. **Merge Sort:** $\Theta(n \lg n)$ in all cases, optimal for comparison-based sorting
3. **Asymptotic Superiority:** $\Theta(n \lg n)$ beats $\Theta(n^2)$ for large inputs
4. **Practical Crossover:** Merge sort typically faster for $n > 30$

## Course Integration

This index covers core algorithmic concepts essential for understanding computational complexity and algorithm design, building on graph theory fundamentals covered in [[Graph Theory Index]].

---
#### Sources
[[lecture_3_sorting_algorithms_computational_cost.pdf]]
#### Class
[[Fundamentals of Computer Science]]